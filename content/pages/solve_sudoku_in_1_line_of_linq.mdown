Date: 2009-11-17 00:21:00
Flags: draft
Description:
Categories: C#, LinQ, programming
Keywords:
Summary:

# Solve Sudoku in 1 line of Linq

<p align="left">One of my coworkers sent around a link today to someone who solved <a title="Sudoku solved in 1 line of SQL" href="http://technology.amis.nl/blog/6404/oracle-rdbms-11gr2-solving-a-sudoku-using-recursive-subquery-factoring">Sudoku puzzles in 1 line of SQL</a> using Oracle's custom recursive syntax. I thought it would be fun to try to convert this into Linq. This is the &quot;best&quot; I was able to come up with. Just like all 1 line solution to complex problems the result looks horrific, although I'm happy to see that it solves the Sudoku puzzles quite quickly.</p>  <p align="left">The solution I used is the <a title="Algorithmics of sudoku" href="http://en.wikipedia.org/wiki/Algorithmics_of_sudoku">standard brute force algorithm</a> that many people use to solve the puzzles manually. The solution checks all numbers 1 - 9 in turn on each empty spot looking for the number in the column, row, and group of 3.</p>  <p align="left">This is accomplished by creating a tree structure of all possible &quot;moves&quot;. The board starts as the root node and each branch is made up of filling in 1 empty spot with all possible numbers that fit the puzzle rules. Each level of the tree tries to solve another empty slot. This also means that the leaf node with the greatest depth is the solution to the puzzle.</p>  <div style="display:inline;float:none;margin:0;padding:0;" id="scid:9ce6104f-a9aa-4a17-a79f-3a39532ebf7c:2790ebba-8233-46b8-8fae-63a5d94a23fe" class="wlWriterEditableSmartContent"> <div style="border:#000080 1px solid;color:#000;font-family:'Courier New', Courier, Monospace;font-size:10pt;"> <div style="background-color:#ffffff;overflow:auto;white-space:nowrap;padding:2px 5px;"><span style="color:#0000ff;">public</span> <span style="color:#0000ff;">static</span> <span style="color:#0000ff;">string</span> SolveStrings(<span style="color:#0000ff;">string</span> Board)<br /> {<br /> &#160;&#160;&#160;&#160;<span style="color:#0000ff;">string</span>[] leafNodesOfMoves = <span style="color:#0000ff;">new</span> <span style="color:#0000ff;">string</span>[] { Board };<br /> &#160;&#160;&#160;&#160;<span style="color:#0000ff;">while</span> ((leafNodesOfMoves.Length &gt; 0) &amp;&amp; (leafNodesOfMoves[0].IndexOf(<span style="color:#a31515;">&#039; &#039;</span>) != -1))<br /> &#160;&#160;&#160;&#160;{<br /> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;leafNodesOfMoves = (<br /> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span style="color:#0000ff;">from</span> partialSolution <span style="color:#0000ff;">in</span> leafNodesOfMoves<br /> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span style="color:#0000ff;">let</span> index = partialSolution.IndexOf(<span style="color:#a31515;">&#039; &#039;</span>)<br /> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span style="color:#0000ff;">let</span> column = index % 9<br /> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span style="color:#0000ff;">let</span> groupOf3 = index - (index % 27) + column - (index % 3)<br /> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span style="color:#0000ff;">from</span> searchLetter <span style="color:#0000ff;">in</span> <span style="color:#a31515;">&quot;123456789&quot;</span><br /> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span style="color:#0000ff;">let</span> InvalidPositions =<br /> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span style="color:#0000ff;">from</span> spaceToCheck <span style="color:#0000ff;">in</span> <span style="color:#2b91af;">Enumerable</span>.Range(0, 9)<br /> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span style="color:#0000ff;">let</span> IsInRow = partialSolution[index - column + spaceToCheck] == searchLetter<br /> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span style="color:#0000ff;">let</span> IsInColumn = partialSolution[column + (spaceToCheck * 9)] == searchLetter<br /> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span style="color:#0000ff;">let</span> IsInGroupBoxOf3x3 = partialSolution[groupOf3 + (spaceToCheck % 3) +<br /> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(<span style="color:#0000ff;">int</span>)<span style="color:#2b91af;">Math</span>.Floor(spaceToCheck / 3f) * 9] == searchLetter<br /> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span style="color:#0000ff;">where</span> IsInRow || IsInColumn || IsInGroupBoxOf3x3<br /> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span style="color:#0000ff;">select</span> spaceToCheck<br /> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span style="color:#0000ff;">where</span> InvalidPositions.Count() == 0<br /> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span style="color:#0000ff;">select</span> partialSolution.Substring(0, index) + searchLetter + partialSolution.Substring(index + 1)<br /> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;).ToArray();<br /> &#160;&#160;&#160;&#160;}<br /> &#160;&#160;&#160;&#160;<span style="color:#0000ff;">return</span> (leafNodesOfMoves.Length == 0)<br /> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;? <span style="color:#a31515;">&quot;No solution&quot;</span><br /> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: leafNodesOfMoves[0];<br /> }</div> </div> </div>  <p>This function takes a string representing the puzzle board. Each row is listed right after the last. If the space is empty then the character spot has a space. The linked article uses this board as an example. And the Wikipedia article has a super hard board that will take 30 minutes to solve.</p>  <p><strong>Easy board</strong>: &quot;53 7 6 195 98 6 8 6 34 8 3 17 2 6 6 28 419 5 8 79&quot;    <br /><strong>Hard board</strong>: &quot;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 3 85&#160; 1 2&#160;&#160;&#160;&#160;&#160;&#160; 5 7&#160;&#160;&#160;&#160; 4&#160;&#160; 1&#160;&#160; 9&#160;&#160;&#160;&#160;&#160;&#160; 5&#160;&#160;&#160;&#160;&#160; 73&#160; 2 1&#160;&#160;&#160;&#160;&#160;&#160;&#160; 4&#160;&#160; 9&quot;</p>
